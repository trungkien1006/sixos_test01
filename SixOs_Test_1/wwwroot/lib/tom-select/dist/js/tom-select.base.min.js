(function (n, t) { typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (n = typeof globalThis != "undefined" ? globalThis : n || self, n.TomSelect = t()) })(this, function () {
    "use strict"; function k(n, t) { n.split(/\s+/).forEach(n => { t(n) }) } function oi(n) { return n.plugins = {}, class extends n { constructor(...n) { super(...n); this.plugins = { names: [], settings: {}, requested: {}, loaded: {} } } static define(t, i) { n.plugins[t] = { name: t, fn: i } } initializePlugins(n) { var t, u; const r = this, i = []; if (Array.isArray(n)) n.forEach(n => { typeof n == "string" ? i.push(n) : (r.plugins.settings[n.name] = n.options, i.push(n.name)) }); else if (n) for (t in n) n.hasOwnProperty(t) && (r.plugins.settings[t] = n[t], i.push(t)); while (u = i.shift()) r.require(u) } loadPlugin(t) { var i = this, r = i.plugins, u = n.plugins[t]; if (!n.plugins.hasOwnProperty(t)) throw new Error('Unable to find "' + t + '" plugin'); r.requested[t] = !0; r.loaded[t] = u.fn.apply(i, [i.plugins.settings[t] || {}]); r.names.push(t) } require(n) { var t = this, i = t.plugins; if (!t.plugins.loaded.hasOwnProperty(n)) { if (i.requested[n]) throw new Error('Plugin has circular dependency ("' + n + '")'); t.loadPlugin(n) } return i.loaded[n] } } } function* wi(n) { for (const [t, i] of n) for (let n = t; n <= i; n++) { let i = String.fromCharCode(n), t = y(i); t != i.toLowerCase() && (t.length > ai || t.length != 0 && (yield { folded: t, composed: i, code_point: n })) } } function fi(n, t) { var i = Object.assign({}, et, t), s = i.dataAttr, h = i.labelField, e = i.valueField, o = i.disabledField, u = i.optgroupField, v = i.optgroupLabelField, l = i.optgroupValueField, y = n.tagName.toLowerCase(), a = n.getAttribute("placeholder") || n.getAttribute("data-placeholder"); if (!a && !i.allowEmptyOption) { let t = n.querySelector('option[value=""]'); t && (a = t.textContent) } var r = { placeholder: a, options: [], optgroups: [], items: [], maxItems: null }, p = () => { var a, w = r.options, t = {}, b = 1, y = n => { var t = Object.assign({}, n.dataset), i = s && t[s]; return typeof i == "string" && i.length && (t = Object.assign(t, JSON.parse(i))), t }, p = (n, s) => { var l = f(n.value), a, c; l != null && (l || i.allowEmptyOption) && (t.hasOwnProperty(l) ? s && (a = t[l][u], a ? Array.isArray(a) ? a.push(s) : t[l][u] = [a, s] : t[l][u] = s) : (c = y(n), c[h] = c[h] || n.textContent, c[e] = c[e] || l, c[o] = c[o] || n.disabled, c[u] = c[u] || s, c.$option = n, t[l] = c, w.push(c)), n.selected && r.items.push(l)) }, k = n => { var i, t; t = y(n); t[v] = t[v] || n.getAttribute("label") || ""; t[l] = t[l] || b++; t[o] = t[o] || n.disabled; r.optgroups.push(t); i = t[l]; c(n.children, n => { p(n, i) }) }; r.maxItems = n.hasAttribute("multiple") ? null : 1; c(n.children, n => { a = n.tagName.toLowerCase(), a === "optgroup" ? k(n) : a === "option" && p(n) }) }, w = () => { const t = n.getAttribute(s); if (t) r.options = JSON.parse(t), c(r.options, n => { r.items.push(n[e]) }); else { var u = n.value.trim() || ""; if (!i.allowEmptyOption && !u.length) return; const t = u.split(i.delimiter); c(t, n => { const t = {}; t[h] = n; t[e] = n; r.options.push(t) }); r.items = t } }; return y === "select" ? p() : w(), Object.assign({}, et, r, t) } var et, ht; class ei { constructor() { this._events = void 0; this._events = {} } on(n, t) { k(n, n => { const i = this._events[n] || []; i.push(t); this._events[n] = i }) } off(n, t) { var i = arguments.length; if (i === 0) { this._events = {}; return } k(n, n => { if (i === 1) { delete this._events[n]; return } const r = this._events[n]; r !== undefined && (r.splice(r.indexOf(t), 1), this._events[n] = r) }) } trigger(n, ...t) { var i = this; k(n, n => { const r = i._events[n]; r !== undefined && r.forEach(n => { n.apply(i, t) }) }) } }
    /*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
    const a = n => (n = n.filter(Boolean), n.length < 2) ? n[0] || "" : hi(n) == 1 ? "[" + n.join("") + "]" : "(?:" + n.join("|") + ")", ct = n => { if (!si(n)) return n.join(""); let i = "", t = 0; const r = () => { t > 1 && (i += "{" + t + "}") }; return n.forEach((u, f) => { if (u === n[f - 1]) { t++; return } r(); i += u; t = 1 }), r(), i }, lt = n => { let t = d(n); return a(t) }, si = n => new Set(n).size !== n.length, l = n => (n + "").replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, "\\$1"), hi = n => n.reduce((n, t) => Math.max(n, ci(t)), 0), ci = n => d(n).length, d = n => Array.from(n);
    /*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
    const at = n => { if (n.length === 1) return [[n]]; let t = []; const i = n.substring(1), r = at(i); return r.forEach(function (i) { let r = i.slice(0); r[0] = n.charAt(0) + r[0]; t.push(r); r = i.slice(0); r.unshift(n.charAt(0)); t.push(r) }), t };
    /*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
    const li = [[0, 65535]]; let v, vt; const ai = 3, g = {}, yt = { "/": "⁄∕", "0": "߀", a: "ⱥɐɑ", aa: "ꜳ", ae: "æǽǣ", ao: "ꜵ", au: "ꜷ", av: "ꜹꜻ", ay: "ꜽ", b: "ƀɓƃ", c: "ꜿƈȼↄ", d: "đɗɖᴅƌꮷԁɦ", e: "ɛǝᴇɇ", f: "ꝼƒ", g: "ǥɠꞡᵹꝿɢ", h: "ħⱨⱶɥ", i: "ɨı", j: "ɉȷ", k: "ƙⱪꝁꝃꝅꞣ", l: "łƚɫⱡꝉꝇꞁɭ", m: "ɱɯϻ", n: "ꞥƞɲꞑᴎлԉ", o: "øǿɔɵꝋꝍᴑ", oe: "œ", oi: "ƣ", oo: "ꝏ", ou: "ȣ", p: "ƥᵽꝑꝓꝕρ", q: "ꝗꝙɋ", r: "ɍɽꝛꞧꞃ", s: "ßȿꞩꞅʂ", t: "ŧƭʈⱦꞇ", th: "þ", tz: "ꜩ", u: "ʉ", v: "ʋꝟʌ", vy: "ꝡ", w: "ⱳ", y: "ƴɏỿ", z: "ƶȥɀⱬꝣ", hv: "ƕ" }; for (let n in yt) { let t = yt[n] || ""; for (let i = 0; i < t.length; i++) { let r = t.substring(i, i + 1); g[r] = n } } const vi = new RegExp(Object.keys(g).join("|") + "|[̀-ͯ·ʾʼ]", "gu"), yi = n => { v === undefined && (v = ki(n || li)) }, pt = (n, t = "NFKD") => n.normalize(t), y = n => d(n).reduce((n, t) => n + pi(t), ""), pi = n => (n = pt(n).toLowerCase().replace(vi, n => g[n] || ""), pt(n, "NFC")); const bi = n => { const t = {}, i = (n, i) => { const r = t[n] || new Set, u = new RegExp("^" + lt(r) + "$", "iu"); i.match(u) || (r.add(l(i)), t[n] = r) }; for (let t of wi(n)) i(t.folded, t.folded), i(t.folded, t.composed); return t }, ki = n => { const i = bi(n), r = {}; let t = []; for (let n in i) { let u = i[n]; u && (r[n] = lt(u)); n.length > 1 && t.push(l(n)) } t.sort((n, t) => t.length - n.length); const u = a(t); return vt = new RegExp("^" + u, "u"), r }, di = (n, t = 1) => { let i = 0; return (n = n.map(n => (v[n] && (i += n.length), v[n] || n)), i >= t) ? ct(n) : "" }, gi = (n, t = 1) => (t = Math.max(t, n.length - 1), a(at(n).map(n => di(n, t)))), wt = (n, t = true) => { let i = n.length > 1 ? 1 : 0; return a(n.map(n => { let r = []; const u = t ? n.length() : n.length() - 1; for (let t = 0; t < u; t++)r.push(gi(n.substrs[t] || "", i)); return ct(r) })) }, nr = (n, t) => { for (const i of t) if (i.start == n.start && i.end == n.end && i.substrs.join("") === n.substrs.join("")) { let t = n.parts; const r = n => { for (const i of t) { if (i.start === n.start && i.substr === n.substr) return !1; if (n.length != 1 && i.length != 1 && (n.start < i.start && n.end > i.start || i.start < n.start && i.end > n.start)) return !0 } return !1 }; let u = i.parts.filter(r); if (!(u.length > 0)) return !0 } return !1 }; class nt { constructor() { this.parts = []; this.substrs = []; this.start = 0; this.end = 0 } add(n) { n && (this.parts.push(n), this.substrs.push(n.substr), this.start = Math.min(n.start, this.start), this.end = Math.max(n.end, this.end)) } last() { return this.parts[this.parts.length - 1] } length() { return this.parts.length } clone(n, t) { let i = new nt, u = JSON.parse(JSON.stringify(this.parts)), r = u.pop(); for (const n of u) i.add(n); let f = t.substr.substring(0, n - r.start), e = f.length; return i.add({ start: r.start, end: r.start + e, length: e, substr: f }), i } } const tr = n => { yi(); n = y(n); let i = "", t = [new nt]; for (let r = 0; r < n.length; r++) { let s = n.substring(r), o = s.match(vt); const h = n.substring(r, r + 1), u = o ? o[0] : null; let f = [], e = new Set; for (const n of t) { const t = n.last(); if (!t || t.length == 1 || t.end <= r) if (u) { const t = u.length; n.add({ start: r, end: r + t, length: t, substr: u }); e.add("1") } else n.add({ start: r, end: r + 1, length: 1, substr: h }), e.add("2"); else if (u) { let i = n.clone(r, t); const e = u.length; i.add({ start: r, end: r + e, length: e, substr: u }); f.push(i) } else e.add("3") } if (f.length > 0) { f = f.sort((n, t) => n.length() - t.length()); for (let n of f) nr(n, t) || t.push(n); continue } if (r > 0 && e.size == 1 && !e.has("3")) { i += wt(t, !1); let n = new nt; const r = t[0]; r && n.add(r.last()); t = [n] } } return i += wt(t, !0) };
    /*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) */
    const ir = (n, t) => { if (n) return n[t] }, rr = (n, t) => { if (n) { for (var i, r = t.split("."); (i = r.shift()) && (n = n[i]);); return n } }, tt = (n, t, i) => { var r, u; return n ? (n = n + "", t.regex == null) ? 0 : (u = n.search(t.regex), u === -1) ? 0 : (r = t.string.length / n.length, u === 0 && (r += .5), r * i) : 0 }, it = (n, t) => { var i = n[t]; if (typeof i == "function") return i; i && !Array.isArray(i) && (n[t] = [i]) }, i = (n, t) => { if (Array.isArray(n)) n.forEach(t); else for (var i in n) n.hasOwnProperty(i) && t(n[i], i) }, ur = (n, t) => typeof n == "number" && typeof t == "number" ? n > t ? 1 : n < t ? -1 : 0 : (n = y(n + "").toLowerCase(), t = y(t + "").toLowerCase(), n > t) ? 1 : t > n ? -1 : 0;
    /*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) */
    class fr { constructor(n, t) { this.items = void 0; this.settings = void 0; this.items = n; this.settings = t || { diacritics: !0 } } tokenize(n, t, i) { if (!n || !n.length) return []; const u = [], f = n.split(/\s+/); var r; return i && (r = new RegExp("^(" + Object.keys(i).map(l).join("|") + "):(.*)$")), f.forEach(n => { let f, e = null, i = null; r && (f = n.match(r)) && (e = f[1], n = f[2]); n.length > 0 && (i = this.settings.diacritics ? tr(n) || null : l(n), i && t && (i = "\\b" + i)); u.push({ string: n, regex: i ? new RegExp(i, "iu") : null, field: e }) }), u } getScoreFunction(n, t) { var i = this.prepareSearch(n, t); return this._getScoreFunction(i) } _getScoreFunction(n) { const t = n.tokens, r = t.length; if (!r) return function () { return 0 }; const o = n.options.fields, s = n.weights, u = o.length, f = n.getAttrFn; if (!u) return function () { return 1 }; const e = function () { return u === 1 ? function (n, t) { const i = o[0].field; return tt(f(t, i), n, s[i] || 1) } : function (n, t) { var r = 0; if (n.field) { const i = f(t, n.field); r += !n.regex && i ? 1 / u : tt(i, n, 1) } else i(s, (i, u) => { r += tt(f(t, u), n, i) }); return r / u } }(); return r === 1 ? function (n) { return e(t[0], n) } : n.options.conjunction === "and" ? function (n) { var i, u = 0; for (let r of t) { if (i = e(r, n), i <= 0) return 0; u += i } return u / r } : function (n) { var u = 0; return i(t, t => { u += e(t, n) }), u / r } } getSortFunction(n, t) { var i = this.prepareSearch(n, t); return this._getSortFunction(i) } _getSortFunction(n) { var r, t = []; const e = this, u = n.options, i = !n.query && u.sort_empty ? u.sort_empty : u.sort; if (typeof i == "function") return i.bind(this); const f = function (t, i) { return t === "$score" ? i.score : n.getAttrFn(e.items[i.id], t) }; if (i) for (let r of i) (n.query || r.field !== "$score") && t.push(r); if (n.query) { r = !0; for (let n of t) if (n.field === "$score") { r = !1; break } r && t.unshift({ field: "$score", direction: "desc" }) } else t = t.filter(n => n.field !== "$score"); const o = t.length; return o ? function (n, i) { var r, u; for (let e of t) { u = e.field; let t = e.direction === "desc" ? -1 : 1; if (r = t * ur(f(u, n), f(u, i)), r) return r } return 0 } : null } prepareSearch(n, t) { const r = {}; var i = Object.assign({}, t); if (it(i, "sort"), it(i, "sort_empty"), i.fields) { it(i, "fields"); const n = []; i.fields.forEach(t => { typeof t == "string" && (t = { field: t, weight: 1 }), n.push(t), r[t.field] = "weight" in t ? t.weight : 1 }); i.fields = n } return { options: i, query: n.toLowerCase().trim(), tokens: this.tokenize(n, i.respect_word_boundaries, r), total: 0, items: [], weights: r, getAttrFn: i.nesting ? rr : ir } } search(n, t) { var u = this, f, r; r = this.prepareSearch(n, t); t = r.options; n = r.query; const o = t.score || u._getScoreFunction(r); n.length ? i(u.items, (n, i) => { f = o(n), (t.filter === !1 || f > 0) && r.items.push({ score: f, id: i }) }) : i(u.items, (n, t) => { r.items.push({ score: 1, id: t }) }); const e = u._getSortFunction(r); return e && r.items.sort(e), r.total = r.items.length, typeof t.limit == "number" && (r.items = r.items.slice(0, t.limit)), r } } const c = (n, t) => { if (Array.isArray(n)) n.forEach(t); else for (var i in n) n.hasOwnProperty(i) && t(n[i], i) }, e = n => { if (n.jquery) return n[0]; if (n instanceof HTMLElement) return n; if (bt(n)) { var t = document.createElement("template"); return t.innerHTML = n.trim(), t.content.firstChild } return document.querySelector(n) }, bt = n => typeof n == "string" && n.indexOf("<") > -1 ? !0 : !1, er = n => n.replace(/['"\\]/g, "\\$&"), rt = (n, t) => { var i = document.createEvent("HTMLEvents"); i.initEvent(t, !0, !1); n.dispatchEvent(i) }, p = (n, t) => { Object.assign(n.style, t) }, u = (n, ...t) => { var i = kt(t); n = dt(n); n.map(n => { i.map(t => { n.classList.add(t) }) }) }, o = (n, ...t) => { var i = kt(t); n = dt(n); n.map(n => { i.map(t => { n.classList.remove(t) }) }) }, kt = n => { var t = []; return c(n, n => { typeof n == "string" && (n = n.trim().split(/[\11\12\14\15\40]/)), Array.isArray(n) && (t = t.concat(n)) }), t.filter(Boolean) }, dt = n => (Array.isArray(n) || (n = [n]), n), ut = (n, t, i) => { if (!i || i.contains(n)) while (n && n.matches) { if (n.matches(t)) return n; n = n.parentNode } }, gt = (n, t = 0) => t > 0 ? n[n.length - 1] : n[0], or = n => Object.keys(n).length === 0, ni = (n, t) => { if (!n) return -1; t = t || n.nodeName; for (var i = 0; n = n.previousElementSibling;)n.matches(t) && i++; return i }, n = (n, t) => { c(t, (t, i) => { t == null ? n.removeAttribute(i) : n.setAttribute(i, "" + t) }) }, ft = (n, t) => { n.parentNode && n.parentNode.replaceChild(t, n) }, sr = (n, t) => { if (t !== null) { if (typeof t == "string") { if (!t.length) return; t = new RegExp(t, "i") } const r = n => { var u = n.data.match(t), i, r, f; return u && n.data.length > 0 ? (i = document.createElement("span"), i.className = "highlight", r = n.splitText(u.index), r.splitText(u[0].length), f = r.cloneNode(!0), i.appendChild(f), ft(r, i), 1) : 0 }, u = n => { n.nodeType === 1 && n.childNodes && !/(script|style)/i.test(n.tagName) && (n.className !== "highlight" || n.tagName !== "SPAN") && Array.from(n.childNodes).forEach(n => { i(n) }) }, i = n => n.nodeType === 3 ? r(n) : (u(n), 0); i(n) } }, hr = n => { var t = n.querySelectorAll("span.highlight"); Array.prototype.forEach.call(t, function (n) { var t = n.parentNode; t.replaceChild(n.firstChild, n); t.normalize() }) }, cr = 65, lr = 13, ar = 27, vr = 37, yr = 38, pr = 39, wr = 40, ti = 8, br = 46, ii = 9, kr = typeof navigator == "undefined" ? !1 : /Mac/.test(navigator.userAgent), w = kr ? "metaKey" : "ctrlKey"; et = { options: [], optgroups: [], plugins: [], delimiter: ",", splitOn: null, persist: !0, diacritics: !0, create: null, createOnBlur: !1, createFilter: null, highlight: !0, openOnFocus: !0, shouldOpen: null, maxOptions: 50, maxItems: null, hideSelected: null, duplicates: !1, addPrecedence: !1, selectOnTab: !1, preload: null, allowEmptyOption: !1, loadThrottle: 300, loadingClass: "loading", dataAttr: null, optgroupField: "optgroup", valueField: "value", labelField: "text", disabledField: "disabled", optgroupLabelField: "label", optgroupValueField: "value", lockOptgroupOrder: !1, sortField: "$order", searchField: ["text"], searchConjunction: "and", mode: null, wrapperClass: "ts-wrapper", controlClass: "ts-control", dropdownClass: "ts-dropdown", dropdownContentClass: "ts-dropdown-content", itemClass: "item", optionClass: "option", dropdownParent: null, controlInput: '<input type="text" autocomplete="off" size="1" />', copyClassesToDropdown: !1, placeholder: null, hidePlaceholder: null, shouldLoad: function (n) { return n.length > 0 }, render: {} }; const f = n => typeof n == "undefined" || n === null ? null : b(n), b = n => typeof n == "boolean" ? n ? "1" : "0" : n + "", ot = n => (n + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;"), dr = (n, t) => { var i; return function (r, u) { var f = this; i && (f.loading = Math.max(f.loading - 1, 0), clearTimeout(i)); i = setTimeout(function () { i = null; f.loadedSearches[r] = !0; n.call(f, r, u) }, t) } }, ri = (n, t, i) => { var r, u = n.trigger, f = {}; n.trigger = function () { var i = arguments[0]; if (t.indexOf(i) !== -1) f[i] = arguments; else return u.apply(n, arguments) }; i.apply(n, []); n.trigger = u; for (r of t) r in f && u.apply(n, f[r]) }, gr = n => ({ start: n.selectionStart || 0, length: (n.selectionEnd || 0) - (n.selectionStart || 0) }), t = (n, t = false) => { n && (n.preventDefault(), t && n.stopPropagation()) }, r = (n, t, i, r) => { n.addEventListener(t, i, r) }, s = (n, t) => { if (!t || !t[n]) return !1; var i = (t.altKey ? 1 : 0) + (t.ctrlKey ? 1 : 0) + (t.shiftKey ? 1 : 0) + (t.metaKey ? 1 : 0); return i === 1 ? !0 : !1 }, st = (n, t) => { const i = n.getAttribute("id"); return i ? i : (n.setAttribute("id", t), t) }, ui = n => n.replace(/[\\"']/g, "\\$&"), h = (n, t) => { t && n.append(t) }; ht = 0; class nu extends oi(ei) { constructor(t, r) { var p, o, w, c, s, d; if (super(), this.control_input = void 0, this.wrapper = void 0, this.dropdown = void 0, this.control = void 0, this.dropdown_content = void 0, this.focus_node = void 0, this.order = 0, this.settings = void 0, this.input = void 0, this.tabIndex = void 0, this.is_select_tag = void 0, this.rtl = void 0, this.inputId = void 0, this._destroy = void 0, this.sifter = void 0, this.isOpen = !1, this.isDisabled = !1, this.isRequired = void 0, this.isInvalid = !1, this.isValid = !0, this.isLocked = !1, this.isFocused = !1, this.isInputHidden = !1, this.isSetup = !1, this.ignoreFocus = !1, this.ignoreHover = !1, this.hasOptions = !1, this.currentResults = void 0, this.lastValue = "", this.caretPos = 0, this.loading = 0, this.loadedSearches = {}, this.activeOption = null, this.activeItems = [], this.optgroups = {}, this.options = {}, this.userOptions = {}, this.items = [], ht++, o = e(t), o.tomselect) throw new Error("Tom Select already initialized on this element"); o.tomselect = this; w = window.getComputedStyle && window.getComputedStyle(o, null); p = w.getPropertyValue("direction"); const f = fi(o, r); this.settings = f; this.input = o; this.tabIndex = o.tabIndex || 0; this.is_select_tag = o.tagName.toLowerCase() === "select"; this.rtl = /rtl/i.test(p); this.inputId = st(o, "tomselect-" + ht); this.isRequired = o.required; this.sifter = new fr(this.options, { diacritics: f.diacritics }); f.mode = f.mode || (f.maxItems === 1 ? "single" : "multi"); typeof f.hideSelected != "boolean" && (f.hideSelected = f.mode === "multi"); typeof f.hidePlaceholder != "boolean" && (f.hidePlaceholder = f.mode !== "multi"); c = f.createFilter; typeof c != "function" && (typeof c == "string" && (c = new RegExp(c)), f.createFilter = c instanceof RegExp ? n => c.test(n) : n => this.settings.duplicates || !this.options[n]); this.initializePlugins(f.plugins); this.setupCallbacks(); this.setupTemplates(); const v = e("<div>"), l = e("<div>"), a = this._render("dropdown"), y = e(`<div role="listbox" tabindex="-1">`), b = this.input.getAttribute("class") || "", k = f.mode; u(v, f.wrapperClass, b, k); u(l, f.controlClass); h(v, l); u(a, f.dropdownClass, k); f.copyClassesToDropdown && u(a, b); u(y, f.dropdownContentClass); h(a, y); e(f.dropdownParent || v).appendChild(a); bt(f.controlInput) ? (s = e(f.controlInput), d = ["autocorrect", "autocapitalize", "autocomplete"], i(d, t => { o.getAttribute(t) && n(s, { [t]: o.getAttribute(t) }) }), s.tabIndex = -1, l.appendChild(s), this.focus_node = s) : f.controlInput ? (s = e(f.controlInput), this.focus_node = s) : (s = e("<input/>"), this.focus_node = l); this.wrapper = v; this.dropdown = a; this.dropdown_content = y; this.control = l; this.control_input = s; this.setup() } setup() { const i = this, f = i.settings, o = i.control_input, s = i.dropdown, y = i.dropdown_content, v = i.wrapper, p = i.control, e = i.input, h = i.focus_node, w = { passive: !0 }, b = i.inputId + "-ts-dropdown"; n(y, { id: b }); n(h, { role: "combobox", "aria-haspopup": "listbox", "aria-expanded": "false", "aria-controls": b }); const g = st(h, i.inputId + "-ts-control"), nt = "label[for='" + er(i.inputId) + "']", c = document.querySelector(nt), k = i.focus.bind(i); if (c) { r(c, "click", k); n(c, { "for": g }); const t = st(c, i.inputId + "-ts-label"); n(h, { "aria-labelledby": t }); n(y, { "aria-labelledby": t }) } if (v.style.width = e.style.width, i.plugins.names.length) { const n = "plugin-" + i.plugins.names.join(" plugin-"); u([v, s], n) } (f.maxItems === null || f.maxItems > 1) && i.is_select_tag && n(e, { multiple: "multiple" }); f.placeholder && n(o, { placeholder: f.placeholder }); !f.splitOn && f.delimiter && (f.splitOn = new RegExp("\\s*" + l(f.delimiter) + "+\\s*")); f.load && f.loadThrottle && (f.load = dr(f.load, f.loadThrottle)); i.control_input.type = e.type; r(s, "mousemove", () => { i.ignoreHover = !1 }); r(s, "mouseenter", n => { var t = ut(n.target, "[data-selectable]", s); if (t) i.onOptionHover(n, t) }, { capture: !0 }); r(s, "click", n => { const r = ut(n.target, "[data-selectable]"); if (r) { i.onOptionSelect(n, r); t(n, !0) } }); r(p, "click", n => { var r = ut(n.target, "[data-ts-item]", p); if (r && i.onItemSelect(n, r)) { t(n, !0); return } o.value == "" && (i.onClick(), t(n, !0)) }); r(h, "keydown", n => i.onKeyDown(n)); r(o, "keypress", n => i.onKeyPress(n)); r(o, "input", n => i.onInput(n)); r(h, "blur", n => i.onBlur(n)); r(h, "focus", n => i.onFocus(n)); r(o, "paste", n => i.onPaste(n)); const d = n => { const r = n.composedPath()[0]; if (!v.contains(r) && !s.contains(r)) { i.isFocused && i.blur(); i.inputState(); return } r == o && i.isOpen ? n.stopPropagation() : t(n, !0) }, a = () => { i.isOpen && i.positionDropdown() }; r(document, "mousedown", d); r(window, "scroll", a, w); r(window, "resize", a, w); this._destroy = () => { document.removeEventListener("mousedown", d), window.removeEventListener("scroll", a), window.removeEventListener("resize", a), c && c.removeEventListener("click", k) }; this.revertSettings = { innerHTML: e.innerHTML, tabIndex: e.tabIndex }; e.tabIndex = -1; e.insertAdjacentElement("afterend", i.wrapper); i.sync(!1); f.items = []; delete f.optgroups; delete f.options; r(e, "invalid", () => { i.isValid && (i.isValid = !1, i.isInvalid = !0, i.refreshState()) }); i.updateOriginalInput(); i.refreshItems(); i.close(!1); i.inputState(); i.isSetup = !0; e.disabled ? i.disable() : i.enable(); i.on("change", this.onChange); u(e, "tomselected", "ts-hidden-accessible"); i.trigger("initialize"); f.preload === !0 && i.preload() } setupOptions(n = [], t = []) { this.addOptions(n); i(t, n => { this.registerOptionGroup(n) }) } setupTemplates() { var n = this, t = n.settings.labelField, i = n.settings.optgroupLabelField, r = { optgroup: n => { let t = document.createElement("div"); return t.className = "optgroup", t.appendChild(n.options), t }, optgroup_header: (n, t) => '<div class="optgroup-header">' + t(n[i]) + "<\/div>", option: (n, i) => "<div>" + i(n[t]) + "<\/div>", item: (n, i) => "<div>" + i(n[t]) + "<\/div>", option_create: (n, t) => '<div class="create">Add <strong>' + t(n.input) + "<\/strong>&hellip;<\/div>", no_results: () => '<div class="no-results">No results found<\/div>', loading: () => '<div class="spinner"><\/div>', not_loading: () => { }, dropdown: () => "<div><\/div>" }; n.settings.render = Object.assign({}, r, n.settings.render) } setupCallbacks() { var n, t, i = { initialize: "onInitialize", change: "onChange", item_add: "onItemAdd", item_remove: "onItemRemove", item_select: "onItemSelect", clear: "onClear", option_add: "onOptionAdd", option_remove: "onOptionRemove", option_clear: "onOptionClear", optgroup_add: "onOptionGroupAdd", optgroup_remove: "onOptionGroupRemove", optgroup_clear: "onOptionGroupClear", dropdown_open: "onDropdownOpen", dropdown_close: "onDropdownClose", type: "onType", load: "onLoad", focus: "onFocus", blur: "onBlur" }; for (n in i) if (t = this.settings[i[n]], t) this.on(n, t) } sync(n = true) { const t = this, i = n ? fi(t.input, { delimiter: t.settings.delimiter }) : t.settings; t.setupOptions(i.options, i.optgroups); t.setValue(i.items || [], !0); t.lastQuery = null } onClick() { var n = this; if (n.activeItems.length > 0) { n.clearActiveItems(); n.focus(); return } n.isFocused && n.isOpen ? n.blur() : n.focus() } onMouseDown() { } onChange() { rt(this.input, "input"); rt(this.input, "change") } onPaste(n) { var r = this; if (r.isInputHidden || r.isLocked) { t(n); return } r.settings.splitOn && setTimeout(() => { var n = r.inputValue(), t; n.match(r.settings.splitOn) && (t = n.trim().split(r.settings.splitOn), i(t, n => { const t = f(n); t && (this.options[n] ? r.addItem(n) : r.createItem(n)) })) }, 0) } onKeyPress(n) { var i = this, r; if (i.isLocked) { t(n); return } if (r = String.fromCharCode(n.keyCode || n.which), i.settings.create && i.settings.mode === "multi" && r === i.settings.delimiter) { i.createItem(); t(n); return } } onKeyDown(n) { var i = this; if (i.ignoreHover = !0, i.isLocked) { n.keyCode !== ii && t(n); return } switch (n.keyCode) { case cr: if (s(w, n) && i.control_input.value == "") { t(n); i.selectAll(); return } break; case ar: i.isOpen && (t(n, !0), i.close()); i.clearActiveItems(); return; case wr: if (!i.isOpen && i.hasOptions) i.open(); else if (i.activeOption) { let n = i.getAdjacent(i.activeOption, 1); n && i.setActiveOption(n) } t(n); return; case yr: if (i.activeOption) { let n = i.getAdjacent(i.activeOption, -1); n && i.setActiveOption(n) } t(n); return; case lr: if (i.canSelect(i.activeOption)) { i.onOptionSelect(n, i.activeOption); t(n) } else i.settings.create && i.createItem() ? t(n) : document.activeElement == i.control_input && i.isOpen && t(n); return; case vr: i.advanceSelection(-1, n); return; case pr: i.advanceSelection(1, n); return; case ii: if (i.settings.selectOnTab) { if (i.canSelect(i.activeOption)) i.onOptionSelect(n, i.activeOption); i.settings.create && i.createItem() } return; case ti: case br: i.deleteSelection(n); return }i.isInputHidden && !s(w, n) && t(n) } onInput() { var n = this, t; n.isLocked || (t = n.inputValue(), n.lastValue !== t && (n.lastValue = t, n.settings.shouldLoad.call(n, t) && n.load(t), n.refreshOptions(!0, !1), n.trigger("type", t))) } onOptionHover(n, t) { this.ignoreHover || this.setActiveOption(t, !1) } onFocus(n) { var i = this, r = i.isFocused; if (i.isDisabled) { i.blur(); t(n); return } i.ignoreFocus || (i.isFocused = !0, i.settings.preload === "focus" && i.preload(), r || i.trigger("focus"), i.activeItems.length || (i.showInput(), i.refreshOptions(!!i.settings.openOnFocus), i.getValue() && i.setActiveOption(i.getOption(i.getValue()))), i.refreshState()) } onBlur() { var n, t; document.hasFocus() !== !1 && (n = this, n.isFocused) && (n.isFocused = !1, n.ignoreFocus = !1, t = () => { n.close(), n.setActiveItem(), n.setCaret(n.items.length), n.trigger("blur") }, n.settings.create && n.settings.createOnBlur ? n.createItem(null, t) : t()) } onOptionSelect(n, t) { var r, i = this; t.parentElement && t.parentElement.matches("[data-disabled]") || (t.classList.contains("create") ? i.createItem(null, () => { i.settings.closeAfterSelect && i.close() }) : (r = t.dataset.value, typeof r != "undefined" && (i.addItem(r), i.settings.closeAfterSelect && i.close(), !i.settings.hideSelected && n.type && /click/.test(n.type) && i.setActiveOption(t)))) } canSelect(n) { return this.isOpen && n && this.dropdown_content.contains(n) ? !0 : !1 } onItemSelect(n, i) { var r = this; return !r.isLocked && r.settings.mode === "multi" ? (t(n), r.setActiveItem(i, n), !0) : !1 } canLoad(n) { return this.settings.load ? this.loadedSearches.hasOwnProperty(n) ? !1 : !0 : !1 } load(n) { const t = this; if (t.canLoad(n)) { u(t.wrapper, t.settings.loadingClass); t.loading++; const i = t.loadCallback.bind(t); t.settings.load.call(t, n, i) } } loadCallback(n, t) { const i = this; i.loading = Math.max(i.loading - 1, 0); i.lastQuery = null; i.clearActiveOption(); i.setupOptions(n, t); i.refreshOptions(i.isFocused && !i.isInputHidden); i.loading || o(i.wrapper, i.settings.loadingClass); i.trigger("load", n, t) } preload() { var n = this.wrapper.classList; n.contains("preloaded") || (n.add("preloaded"), this.load("")) } setTextboxValue(n = "") { var t = this.control_input, i = t.value !== n; i && (t.value = n, rt(t, "update"), this.lastValue = n) } getValue() { return this.is_select_tag && this.input.hasAttribute("multiple") ? this.items : this.items.join(this.settings.delimiter) } setValue(n, t) { var i = t ? [] : ["change"]; ri(this, i, () => { this.clear(t), this.addItems(n, t) }) } setMaxItems(n) { n === 0 && (n = null); this.settings.maxItems = n; this.refreshState() } setActiveItem(n, i) { var r = this, e, o, u, f, h, c; if (r.settings.mode !== "single") { if (!n) { r.clearActiveItems(); r.isFocused && r.showInput(); return } if (e = i && i.type.toLowerCase(), e === "click" && s("shiftKey", i) && r.activeItems.length) { for (c = r.getLastActive(), u = Array.prototype.indexOf.call(r.control.children, c), f = Array.prototype.indexOf.call(r.control.children, n), u > f && (h = u, u = f, f = h), o = u; o <= f; o++)n = r.control.children[o], r.activeItems.indexOf(n) === -1 && r.setActiveItemClass(n); t(i) } else e === "click" && s(w, i) || e === "keydown" && s("shiftKey", i) ? n.classList.contains("active") ? r.removeActiveItem(n) : r.setActiveItemClass(n) : (r.clearActiveItems(), r.setActiveItemClass(n)); r.hideInput(); r.isFocused || r.focus() } } setActiveItemClass(n) { const t = this, i = t.control.querySelector(".last-active"); i && o(i, "last-active"); u(n, "active last-active"); t.trigger("item_select", n); t.activeItems.indexOf(n) == -1 && t.activeItems.push(n) } removeActiveItem(n) { var t = this.activeItems.indexOf(n); this.activeItems.splice(t, 1); o(n, "active") } clearActiveItems() { o(this.activeItems, "active"); this.activeItems = [] } setActiveOption(t, i = true) { (this.clearActiveOption(), t) && (this.activeOption = t, n(this.focus_node, { "aria-activedescendant": t.getAttribute("id") }), n(t, { "aria-selected": "true" }), u(t, "active"), i && this.scrollToOption(t)) } scrollToOption(n, t) { if (n) { const r = this.dropdown_content, f = r.clientHeight, u = r.scrollTop || 0, e = n.offsetHeight, i = n.getBoundingClientRect().top - r.getBoundingClientRect().top + u; i + e > f + u ? this.scroll(i - f + e, t) : i < u && this.scroll(i, t) } } scroll(n, t) { const i = this.dropdown_content; t && (i.style.scrollBehavior = t); i.scrollTop = n; i.style.scrollBehavior = "" } clearActiveOption() { this.activeOption && (o(this.activeOption, "active"), n(this.activeOption, { "aria-selected": null })); this.activeOption = null; n(this.focus_node, { "aria-activedescendant": null }) } selectAll() { const n = this; if (n.settings.mode !== "single") { const t = n.controlChildren(); t.length && (n.hideInput(), n.close(), n.activeItems = t, i(t, t => { n.setActiveItemClass(t) })) } } inputState() { var t = this; t.control.contains(t.control_input) && (n(t.control_input, { placeholder: t.settings.placeholder }), t.activeItems.length > 0 || !t.isFocused && t.settings.hidePlaceholder && t.items.length > 0 ? (t.setTextboxValue(), t.isInputHidden = !0) : (t.settings.hidePlaceholder && t.items.length > 0 && n(t.control_input, { placeholder: "" }), t.isInputHidden = !1), t.wrapper.classList.toggle("input-hidden", t.isInputHidden)) } hideInput() { this.inputState() } showInput() { this.inputState() } inputValue() { return this.control_input.value.trim() } focus() { var n = this; n.isDisabled || (n.ignoreFocus = !0, n.control_input.offsetWidth ? n.control_input.focus() : n.focus_node.focus(), setTimeout(() => { n.ignoreFocus = !1, n.onFocus() }, 0)) } blur() { this.focus_node.blur(); this.onBlur() } getScoreFunction(n) { return this.sifter.getScoreFunction(n, this.getSearchOptions()) } getSearchOptions() { var n = this.settings, t = n.sortField; return typeof n.sortField == "string" && (t = [{ field: n.sortField }]), { fields: n.searchField, conjunction: n.searchConjunction, sort: t, nesting: n.nesting } } search(n) { var i, r, t = this, u = this.getSearchOptions(); if (t.settings.score && (r = t.settings.score.call(t, n), typeof r != "function")) throw new Error('Tom Select "score" setting must be a function that returns a function'); return n !== t.lastQuery ? (t.lastQuery = n, i = t.sifter.search(n, Object.assign(u, { score: r })), t.currentResults = i) : i = Object.assign({}, t.currentResults), t.settings.hideSelected && (i.items = i.items.filter(n => { let i = f(n.id); return !(i && t.items.indexOf(i) !== -1) })), i } refreshOptions(t = true, r = true) { var p, a, ut, v, f, w, k, g, nt, d, u, s, y; const tt = {}, it = []; u = this; s = ""; s = r ? u.lastQuery ? u.lastQuery : u.inputValue() : u.inputValue(); const ft = s === u.lastQuery || s == "" && u.lastQuery == null; var c = u.search(s), e = null, rt = u.settings.shouldOpen || !1, l = u.dropdown_content; for (ft && (e = u.activeOption, e && (nt = e.closest("[data-group]"))), v = c.items.length, typeof u.settings.maxOptions == "number" && (v = Math.min(v, u.settings.maxOptions)), v > 0 && (rt = !0), p = 0; p < v; p++) { let s = c.items[p]; if (s) { let i = s.id, r = u.options[i]; if (r !== undefined) { let h = b(i), t = u.getOption(h, !0); for (u.settings.hideSelected || t.classList.toggle("selected", u.items.includes(h)), f = r[u.settings.optgroupField] || "", w = Array.isArray(f) ? f : [f], a = 0, ut = w && w.length; a < ut; a++) { f = w[a]; u.optgroups.hasOwnProperty(f) || (f = ""); let s = tt[f]; s === undefined && (s = document.createDocumentFragment(), it.push(f)); a > 0 && (t = t.cloneNode(!0), n(t, { id: r.$id + "-clone-" + a, "aria-selected": null }), t.classList.add("ts-cloned"), o(t, "active"), u.activeOption && u.activeOption.dataset.value == i && nt && nt.dataset.group === f.toString() && (e = t)); s.appendChild(t); tt[f] = s } } } } if (u.settings.lockOptgroupOrder && it.sort((n, t) => { const i = u.optgroups[n], r = u.optgroups[t], f = i && i.$order || 0, e = r && r.$order || 0; return f - e }), k = document.createDocumentFragment(), i(it, n => { let t = tt[n]; if (t && t.children.length) { let i = u.optgroups[n]; if (i !== undefined) { let n = document.createDocumentFragment(), r = u.render("optgroup_header", i); h(n, r); h(n, t); let f = u.render("optgroup", { group: i, options: n }); h(k, f) } else h(k, t) } }), l.innerHTML = "", h(l, k), u.settings.highlight && (hr(l), c.query.length && c.tokens.length && i(c.tokens, n => { sr(l, n.regex) })), y = n => { let t = u.render(n, { input: s }); return t && (rt = !0, l.insertBefore(t, l.firstChild)), t }, u.loading ? y("loading") : u.settings.shouldLoad.call(u, s) ? c.items.length === 0 && y("no_results") : y("not_loading"), g = u.canCreate(s), g && (d = y("option_create")), u.hasOptions = c.items.length > 0 || g, rt) { if (c.items.length > 0) { if (e || u.settings.mode !== "single" || u.items[0] == undefined || (e = u.getOption(u.items[0])), !l.contains(e)) { let n = 0; d && !u.settings.addPrecedence && (n = 1); e = u.selectable()[n] } } else d && (e = d); t && !u.isOpen && (u.open(), u.scrollToOption(e, "auto")); u.setActiveOption(e) } else u.clearActiveOption(), t && u.isOpen && u.close(!1) } selectable() { return this.dropdown_content.querySelectorAll("[data-selectable]") } addOption(n, t = false) { const i = this; if (Array.isArray(n)) return i.addOptions(n, t), !1; const r = f(n[i.settings.valueField]); return r === null || i.options.hasOwnProperty(r) ? !1 : (n.$order = n.$order || ++i.order, n.$id = i.inputId + "-opt-" + n.$order, i.options[r] = n, i.lastQuery = null, t && (i.userOptions[r] = t, i.trigger("option_add", r, n)), r) } addOptions(n, t = false) { i(n, n => { this.addOption(n, t) }) } registerOption(n) { return this.addOption(n) } registerOptionGroup(n) { var t = f(n[this.settings.optgroupValueField]); return t === null ? !1 : (n.$order = n.$order || ++this.order, this.optgroups[t] = n, t) } addOptionGroup(n, t) { var i; t[this.settings.optgroupValueField] = n; (i = this.registerOptionGroup(t)) && this.trigger("optgroup_add", i, t) } removeOptionGroup(n) { this.optgroups.hasOwnProperty(n) && (delete this.optgroups[n], this.clearCache(), this.trigger("optgroup_remove", n)) } clearOptionGroups() { this.optgroups = {}; this.clearCache(); this.trigger("optgroup_clear") } updateOption(n, t) { const i = this; var s, h; const r = f(n), o = f(t[i.settings.valueField]); if (r !== null) { const l = i.options[r]; if (l != undefined) { if (typeof o != "string") throw new Error("Value must be set in option data"); const e = i.getOption(r), c = i.getItem(r); if (t.$order = t.$order || l.$order, delete i.options[r], i.uncacheValue(o), i.options[o] = t, e) { if (i.dropdown_content.contains(e)) { const n = i._render("option", t); ft(e, n); i.activeOption === e && i.setActiveOption(n) } e.remove() } c && (h = i.items.indexOf(r), h !== -1 && i.items.splice(h, 1, o), s = i._render("item", t), c.classList.contains("active") && u(s, "active"), ft(c, s)); i.lastQuery = null } } } removeOption(n, t) { const i = this; n = b(n); i.uncacheValue(n); delete i.userOptions[n]; delete i.options[n]; i.lastQuery = null; i.trigger("option_remove", n); i.removeItem(n, t) } clearOptions(n) { const r = (n || this.clearFilter).bind(this); this.loadedSearches = {}; this.userOptions = {}; this.clearCache(); const t = {}; i(this.options, (n, i) => { r(n, i) && (t[i] = n) }); this.options = this.sifter.items = t; this.lastQuery = null; this.trigger("option_clear") } clearFilter(n, t) { return this.items.indexOf(t) >= 0 ? !0 : !1 } getOption(n, t = false) { const r = f(n); if (r === null) return null; const i = this.options[r]; if (i != undefined) { if (i.$div) return i.$div; if (t) return this._render("option", i) } return null } getAdjacent(n, t, i = "option") { var u = this, r; if (!n) return null; r = i == "item" ? u.controlChildren() : u.dropdown_content.querySelectorAll("[data-selectable]"); for (let i = 0; i < r.length; i++)if (r[i] == n) return t > 0 ? r[i + 1] : r[i - 1]; return null } getItem(n) { if (typeof n == "object") return n; var t = f(n); return t !== null ? this.control.querySelector(`[data-value="${ui(t)}"]`) : null } addItems(n, t) { var r = this, i = Array.isArray(n) ? n : [n]; i = i.filter(n => r.items.indexOf(n) === -1); const u = i[i.length - 1]; i.forEach(n => { r.isPending = n !== u, r.addItem(n, t) }) } addItem(n, t) { var i = t ? [] : ["change", "dropdown_close"]; ri(this, i, () => { var u, o; const i = this, e = i.settings.mode, r = f(n); if ((!r || i.items.indexOf(r) === -1 || (e === "single" && i.close(), e !== "single" && i.settings.duplicates)) && r !== null && i.options.hasOwnProperty(r) && (e === "single" && i.clear(t), e !== "multi" || !i.isFull())) { if (u = i._render("item", i.options[r]), i.control.contains(u) && (u = u.cloneNode(!0)), o = i.isFull(), i.items.splice(i.caretPos, 0, r), i.insertAtCaret(u), i.isSetup) { if (!i.isPending && i.settings.hideSelected) { let t = i.getOption(r), n = i.getAdjacent(t, 1); n && i.setActiveOption(n) } i.isPending || i.settings.closeAfterSelect || (i.refreshOptions(i.isFocused && e !== "single")); i.settings.closeAfterSelect != !1 && i.isFull() ? i.close() : i.isPending || i.positionDropdown(); i.trigger("item_add", r, u); i.isPending || i.updateOriginalInput({ silent: t }) } i.isPending && (o || !i.isFull()) || (i.inputState(), i.refreshState()) } }) } removeItem(n = null, t) { const i = this; if (n = i.getItem(n), n) { var r, f; const u = n.dataset.value; r = ni(n); n.remove(); n.classList.contains("active") && (f = i.activeItems.indexOf(n), i.activeItems.splice(f, 1), o(n, "active")); i.items.splice(r, 1); !i.settings.persist && i.userOptions.hasOwnProperty(u) && i.removeOption(u, t); r < i.caretPos && i.setCaret(i.caretPos - 1); i.updateOriginalInput({ silent: t }); i.refreshState(); i.positionDropdown(); i.trigger("item_remove", u, n) } } createItem(n = null, t = () => { }) { var i, e, o, r, u; return (arguments.length === 3 && (t = arguments[2]), typeof t != "function" && (t = () => { }), i = this, e = i.caretPos, n = n || i.inputValue(), !i.canCreate(n)) ? (t(), !1) : (i.lock(), r = !1, u = n => { if (i.unlock(), !n || typeof n != "object") return t(); var u = f(n[i.settings.valueField]); if (typeof u != "string") return t(); i.setTextboxValue(); i.addOption(n, !0); i.setCaret(e); i.addItem(u); t(n); r = !0 }, o = typeof i.settings.create == "function" ? i.settings.create.call(this, n, u) : { [i.settings.labelField]: n, [i.settings.valueField]: n }, r || u(o), !0) } refreshItems() { var n = this; n.lastQuery = null; n.isSetup && n.addItems(n.items); n.updateOriginalInput(); n.refreshState() } refreshState() { const n = this; n.refreshValidityState(); const i = n.isFull(), r = n.isLocked; n.wrapper.classList.toggle("rtl", n.rtl); const t = n.wrapper.classList; t.toggle("focus", n.isFocused); t.toggle("disabled", n.isDisabled); t.toggle("required", n.isRequired); t.toggle("invalid", !n.isValid); t.toggle("locked", r); t.toggle("full", i); t.toggle("input-active", n.isFocused && !n.isInputHidden); t.toggle("dropdown-active", n.isOpen); t.toggle("has-options", or(n.options)); t.toggle("has-items", n.items.length > 0) } refreshValidityState() { var n = this; n.input.validity && (n.isValid = n.input.validity.valid, n.isInvalid = !n.isValid) } isFull() { return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems } updateOriginalInput(n = {}) { const t = this; var i, r; const u = t.input.querySelector('option[value=""]'); if (t.is_select_tag) { const f = [], o = t.input.querySelectorAll("option:checked").length; function n(n, i, r) { return n || (n = e('<option value="' + ot(i) + '">' + ot(r) + "<\/option>")), n != u && t.input.append(n), f.push(n), (n != u || o > 0) && (n.selected = !0), n } t.input.querySelectorAll("option:checked").forEach(n => { n.selected = !1 }); t.items.length == 0 && t.settings.mode == "single" ? n(u, "", "") : t.items.forEach(u => { if (i = t.options[u], r = i[t.settings.labelField] || "", f.includes(i.$option)) { const i = t.input.querySelector(`option[value="${ui(u)}"]:not(:checked)`); n(i, u, r) } else i.$option = n(i.$option, u, r) }) } else t.input.value = t.getValue(); t.isSetup && (n.silent || t.trigger("change", t.getValue())) } open() { var t = this; t.isLocked || t.isOpen || t.settings.mode === "multi" && t.isFull() || (t.isOpen = !0, n(t.focus_node, { "aria-expanded": "true" }), t.refreshState(), p(t.dropdown, { visibility: "hidden", display: "block" }), t.positionDropdown(), p(t.dropdown, { visibility: "visible", display: "block" }), t.focus(), t.trigger("dropdown_open", t.dropdown)) } close(t = true) { var i = this, r = i.isOpen; t && (i.setTextboxValue(), i.settings.mode === "single" && i.items.length && i.hideInput()); i.isOpen = !1; n(i.focus_node, { "aria-expanded": "false" }); p(i.dropdown, { display: "none" }); i.settings.hideSelected && i.clearActiveOption(); i.refreshState(); r && i.trigger("dropdown_close", i.dropdown) } positionDropdown() { if (this.settings.dropdownParent === "body") { var t = this.control, n = t.getBoundingClientRect(), i = t.offsetHeight + n.top + window.scrollY, r = n.left + window.scrollX; p(this.dropdown, { width: n.width + "px", top: i + "px", left: r + "px" }) } } clear(n) { var t = this, r; t.items.length && (r = t.controlChildren(), i(r, n => { t.removeItem(n, !0) }), t.showInput(), n || t.updateOriginalInput(), t.trigger("clear")) } insertAtCaret(n) { const t = this, i = t.caretPos, r = t.control; r.insertBefore(n, r.children[i] || null); t.setCaret(i + 1) } deleteSelection(n) { var u, e, o, s, r = this; u = n && n.keyCode === ti ? -1 : 1; e = gr(r.control_input); const f = []; if (r.activeItems.length) s = gt(r.activeItems, u), o = ni(s), u > 0 && o++, i(r.activeItems, n => f.push(n)); else if ((r.isFocused || r.settings.mode === "single") && r.items.length) { const t = r.controlChildren(); let n; u < 0 && e.start === 0 && e.length === 0 ? n = t[r.caretPos - 1] : u > 0 && e.start === r.inputValue().length && (n = t[r.caretPos]); n !== undefined && f.push(n) } if (!r.shouldDelete(f, n)) return !1; for (t(n, !0), typeof o != "undefined" && r.setCaret(o); f.length;)r.removeItem(f.pop()); return r.showInput(), r.positionDropdown(), r.refreshOptions(!1, !1), !0 } shouldDelete(n, t) { const i = n.map(n => n.dataset.value); return !i.length || typeof this.settings.onDelete == "function" && this.settings.onDelete(i, t) === !1 ? !1 : !0 } advanceSelection(n, t) { var r, u, i = this; (i.rtl && (n *= -1), i.inputValue().length) || (s(w, t) || s("shiftKey", t) ? (r = i.getLastActive(n), u = r ? r.classList.contains("active") ? i.getAdjacent(r, n, "item") : r : n > 0 ? i.control_input.nextElementSibling : i.control_input.previousElementSibling, u && (u.classList.contains("active") && i.removeActiveItem(r), i.setActiveItemClass(u))) : i.moveCaret(n)) } moveCaret() { } getLastActive(n) { let t = this.control.querySelector(".last-active"); if (t) return t; var i = this.control.querySelectorAll(".active"); if (i) return gt(i, n) } setCaret() { this.caretPos = this.items.length } controlChildren() { return Array.from(this.control.querySelectorAll("[data-ts-item]")) } lock() { this.isLocked = !0; this.refreshState() } unlock() { this.isLocked = !1; this.refreshState() } disable() { var n = this; n.input.disabled = !0; n.control_input.disabled = !0; n.focus_node.tabIndex = -1; n.isDisabled = !0; this.close(); n.lock() } enable() { var n = this; n.input.disabled = !1; n.control_input.disabled = !1; n.focus_node.tabIndex = n.tabIndex; n.isDisabled = !1; n.unlock() } destroy() { var n = this, t = n.revertSettings; n.trigger("destroy"); n.off(); n.wrapper.remove(); n.dropdown.remove(); n.input.innerHTML = t.innerHTML; n.input.tabIndex = t.tabIndex; o(n.input, "tomselected", "ts-hidden-accessible"); n._destroy(); delete n.input.tomselect } render(t, i) { var o, r; const f = this; if (typeof this.settings.render[t] != "function" || (r = f.settings.render[t].call(this, i, ot), !r)) return null; if (r = e(r), t === "option" || t === "option_create" ? i[f.settings.disabledField] ? n(r, { "aria-disabled": "true" }) : n(r, { "data-selectable": "" }) : t === "optgroup" && (o = i.group[f.settings.optgroupValueField], n(r, { "data-group": o }), i.group[f.settings.disabledField] && n(r, { "data-disabled": "" })), t === "option" || t === "item") { const e = b(i[f.settings.valueField]); n(r, { "data-value": e }); t === "item" ? (u(r, f.settings.itemClass), n(r, { "data-ts-item": "" })) : (u(r, f.settings.optionClass), n(r, { role: "option", id: i.$id }), i.$div = r, f.options[e] = i) } return r } _render(n, t) { const i = this.render(n, t); if (i == null) throw "HTMLElement expected"; return i } clearCache() { i(this.options, n => { n.$div && (n.$div.remove(), delete n.$div) }) } uncacheValue(n) { const t = this.getOption(n); t && t.remove() } canCreate(n) { return this.settings.create && n.length > 0 && this.settings.createFilter.call(this, n) } hook(n, t, i) { var r = this, u = r[t]; r[t] = function () { var t, f; return (n === "after" && (t = u.apply(r, arguments)), f = i.apply(r, arguments), n === "instead") ? f : (n === "before" && (t = u.apply(r, arguments)), t) } } } return nu
}); var tomSelect = function (n, t) { return new TomSelect(n, t) };